import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib import animation
from matplotlib import transforms
from matplotlib.patches import Circle
import argparse


class CarVisualizer:
    def __init__(self, path_file, obstacles):
        """
        path_file : str
            Path to the text file output from OMPL planner.
        obstacles : list of tuples
            Each obstacle as (x, y, width, height).
        """
        self.path = np.loadtxt(path_file)
        self.obstacles = obstacles
        self.dt = 0.05  # frame interval (s)
        self.L = 0.5    # car length for visualization

        # Extract state variables
        self.x = self.path[:, 0]
        self.y = self.path[:, 1]
        self.theta = self.path[:, 2]
        self.v = self.path[:, 3]

        self.N = len(self.x)
        self.t = np.linspace(0, self.N * self.dt, self.N)

    def draw_environment(self, ax):
        """Draw the static environment (obstacles)."""
        for (x, y, w, h) in self.obstacles:
            rect = patches.Rectangle((x, y), w, h, color="lightgray", ec="black")
            ax.add_patch(rect)
        ax.set_xlim(-10, 15)
        ax.set_ylim(-8, 10)
        ax.set_xlabel("x [m]")
        ax.set_ylabel("y [m]")
        ax.set_aspect('equal', 'box')

    def init_plot(self):
        """Initialize the figure and plot elements."""
        self.fig, self.ax = plt.subplots()
        self.draw_environment(self.ax)

        # Path trace
        (self.path_line,) = self.ax.plot([], [], 'steelblue', lw=1.5)

        # Car body (rectangle)
        self.car_patch = patches.Rectangle((0, 0), self.L, self.L / 2,
                                           fc='firebrick', ec='black', zorder=3)
        self.ax.add_patch(self.car_patch)

        # Heading indicator
        (self.heading_line,) = self.ax.plot([], [], 'gold', lw=2)

        # Information text boxes
        self.text_vel = self.ax.text(-9.5, 8.5, '', fontsize=9,
                                     bbox=dict(boxstyle="round", fc="white"))
        self.text_state = self.ax.text(5, 8.5, '', fontsize=9,
                                       bbox=dict(boxstyle="round", fc="white"))
        self.ax.set_title("Car Trajectory Animation")

        # Goal region marker (optional, same as car.cpp goal)
        goal_circle = Circle((7.0, 4.0), 0.3, color='gold', fill=False, lw=2)
        self.ax.add_patch(goal_circle)

    def update(self, i):
        """Update car position and UI elements for frame i."""
        x = float(self.x[i])
        y = float(self.y[i])
        theta = float(self.theta[i])
        v = float(self.v[i])

        # Update path trace
        self.path_line.set_data(self.x[:i], self.y[:i])

        # Corrected type-safe tuple for car position
        self.car_patch.set_xy((x - self.L / 4, y - self.L / 8))

        # Apply rotation
        tform = (transforms.Affine2D()
            .rotate_around(x, y, theta)
            + self.ax.transData)
        self.car_patch.set_transform(tform)

        # Heading line
        hx = [x, x + self.L * np.cos(theta)]
        hy = [y, y + self.L * np.sin(theta)]
        self.heading_line.set_data(hx, hy)

        # Update HUD text
        self.text_vel.set_text(f"v={v:.2f} m/s")
        self.text_state.set_text(
            f"T={self.t[i]:.2f} s\nx={x:.2f}, y={y:.2f}\nÎ¸={theta:.2f} rad"
        )

        return self.path_line, self.car_patch, self.heading_line, self.text_vel, self.text_state



    def animate(self, output_file=None):
        """Run the animation, optionally saving to a file."""
        self.init_plot()
        ani = animation.FuncAnimation(
            self.fig, self.update, frames=self.N, interval=40, blit=False
        )

        if output_file:
            ani.save(output_file, fps=30)
            print(f"Saved animation to {output_file}")
        else:
            plt.show()


def main():
    parser = argparse.ArgumentParser(
        description="Visualize a car trajectory generated by OMPL planners."
    )
    parser.add_argument("path_file", help="Input path file (e.g., car_path.txt)")
    parser.add_argument(
        "--output", "-o",
        help="Output GIF or MP4 filename (e.g., car_traj.gif). If omitted, animation is shown live.",
        default=None
    )

    args = parser.parse_args()

    # Same obstacle layout as makeStreet() from car.cpp
    obstacles = [
        (5.0, -2.0, 7, 5),
        (-4, 5, 16, 2),
        (-4, -2, 7, 4),
        (8, 3, 4, 2),
    ]

    vis = CarVisualizer(args.path_file, obstacles)
    vis.animate(args.output)


if __name__ == "__main__":
    main()
